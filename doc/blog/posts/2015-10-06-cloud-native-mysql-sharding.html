---
layout: post
title: Cloud Native MySQL Sharding with Vitess and Kubernetes (blog post)
date: 2015-10-06
attribution: Anthony Yeh, Software Engineer, YouTube
---

<p><a href="https://cncf.io/">Cloud native</a> technologies like <a href="http://kubernetes.io/">Kubernetes</a> help you compose scalable services out of a sea of small logical units. In our <a href="/scaling-mysql-in-cloud-with-vitess-and-kubernetes/">last post</a>, we introduced <a href="http://vitess.io/">Vitess</a> (an open-source project that powers YouTube's main database) as a way of turning MySQL into a scalable Kubernetes application. Our goal was to make scaling your persistent datastore in Kubernetes as simple as scaling stateless app servers - just run a single command to launch more <a href="https://github.com/kubernetes/kubernetes/blob/release-1.0/docs/user-guide/pods.md">pods</a>. We've made a lot of progress since then (pushing over 2,500 new commits) and we're nearing the first stable version of the new, cloud native Vitess.</p>

<!-- more -->

<h2>Vitess 2.0</h2>

<p>In preparation for the stable release, we've begun to publish alpha builds of <a href="https://github.com/youtube/vitess/releases">Vitess v2.0.0</a>. Some highlights of what's new since our earlier post include:</p>

<ul>
  <li>Using the final Kubernetes 1.0 API.</li>
  <li>Official <a href="http://vitess.io/user-guide/client-libraries.html">Vitess client libraries</a> in Java, Python, PHP, and Go.</li>
  <li>Java and Go clients use the new HTTP/2-based <a href="http://www.grpc.io/">gRPC</a> framework.</li>
  <li>Can now run on top of MySQL 5.6, in addition to MariaDB 10.0.</li>
  <li>New administrative dashboard built on AngularJS.</li>
  <li>Built-in <a href="http://vitess.io/user-guide/backup-and-restore.html">backup/restore</a>, designed to plug into blob stores like <a href="https://cloud.google.com/storage/">Google Cloud Storage</a>.</li>
  <li>GTID-based <a href="http://vitess.io/user-guide/reparenting.html">reparenting</a> for reversible, routine failovers.</li>
  <li>Simpler <a href="http://vitess.io/user-guide/schema-management.html">schema changes</a>.</li>
</ul>

<p>We've also been hard at work adding lots more <a href="http://vitess.io/user-guide/introduction.html">documentation</a>. In particular, the rest of this post will explore one of our new walkthroughs that demonstrates transparent <a href="http://vitess.io/user-guide/sharding.html#resharding">resharding</a> of a live database - that is, changing the number of shards without any code changes or noticeable downtime for the application.</p>

<h2>Vitess Sharding</h2>

<p><a href="https://eng.asana.com/2015/04/sharding-is-bitter-medicine/">Sharding is bitter medicine</a>, as S. Alex Smith wrote. It complicates your application logic and multiplies your database administration workload. But sharding is especially important when running MySQL in a cloud environment, since a single node can only become so big. Vitess takes care of shard routing logic, so the data-access layer in your application stays simple. It also automates per-shard administrative tasks, helping a small team manage a large fleet.</p>

<p>The preferred sharding strategy in Vitess is what we call <a href="http://vitess.io/user-guide/sharding.html#range-based-sharding">range-based shards</a>. You can think of the shards as being like the buckets of a hash table. We decide which bucket to place a record in based solely on its key, so we don't need a separate table that keeps track of which bucket each key is in.</p>

<p>To make it easy to change the number of buckets, we use <a href="https://en.wikipedia.org/wiki/Consistent_hashing">consistent hashing</a>. That means instead of using a hash function that maps each key to a bucket number, we use a function that maps each key to a randomly distributed (but consistent) value in a very large set - such as the set of all 8-byte sequences. Then we assign each bucket a range of these values, which we call <a href="http://vitess.io/overview/concepts.html#keyspace-id">keyspace IDs</a>.</p>

<h2>Transparent Resharding</h2>

<p>If you want to follow along with the new <a href="http://vitess.io/user-guide/sharding-kubernetes.html">resharding walkthrough</a>, you'll need to first bring up the cluster as described in the <a href="http://vitess.io/getting-started/">unsharded guide</a>. Both guides use the same <a href="https://github.com/youtube/vitess/tree/master/examples/kubernetes/guestbook">sample app</a>, which is a Guestbook that supports multiple, numbered pages.</p>

<img src="/images/blog-2015-10-06-guestbook.png" alt="Screenshot of Vitess Guestbook sample application."/>

<p>In the <a href="https://github.com/youtube/vitess/blob/master/examples/kubernetes/guestbook/main.py">sample app code</a>, you'll see a get_keyspace_id() function that transforms a given page number to the set of all 8-byte sequences, establishing the mapping we need for consistent hashing. In the unsharded case, these values are stored but not used. When we introduce sharding, page numbers will be evenly distributed (on average) across all the shards we create, allowing the app to scale to support arbitrary amounts of pages.</p>

<p>Before resharding, you'll see a single <a href="http://vitess.io/user-guide/sharding.html#custom-sharding">custom shard</a> named "0" in the Vitess dashboard. This is what an unsharded <a href="http://vitess.io/overview/concepts.html#keyspace">keyspace</a> looks like.</p>

<img src="/images/blog-2015-10-06-dashboard-1.png" alt="Screenshot of Vitess dashboard showing test keyspace with one shard at beginning of resharding process."/>

<p>As you begin the <a href="http://vitess.io/user-guide/sharding-kubernetes.html">resharding walkthrough</a>, you'll bring up two new shards for the same keyspace. During resharding, the new shards will run alongside the old one, but they'll remain idle (Vitess will not route any app traffic to them) until you're ready to migrate. In the dashboard, you'll see all three shards, but only shard "0" is currently active.</p>

<img src="/images/blog-2015-10-06-dashboard-2.png" alt="Screenshot of Vitess dashboard showing test keyspace with three shards during resharding process."/>

<p>Next, you'll run a few Vitess commands to <a href="http://vitess.io/user-guide/sharding-kubernetes.html#copy-data-from-original-shard">copy the schema and data</a> from the original shard. The key to live migration is that once the initial snapshot copy is done, Vitess will automatically begin replicating fresh updates on the original shard to the new shards. We call this <a href="http://vitess.io/user-guide/sharding.html#filtered-replication">filtered replication</a>, since it distributes DMLs only to the shards to which they apply. Vitess also includes tools that compare the original and copied data sets, row-by-row, to <a href="http://vitess.io/user-guide/sharding-kubernetes.html#check-copied-data-integrity">verify data integrity</a>.</p>

<p>Once you've verified the copy, and filtered replication has caught up to real-time updates, you can run the <a href="http://vitess.io/user-guide/sharding-kubernetes.html#switch-over-to-the-new-shards">migrate command</a>, which tells Vitess to atomically shift app traffic from the old shards to the new ones. It does this by disabling writes on the old masters, waiting for the new masters to receive the last events over filtered replication, and then enabling writes on the new masters. Since the process is automated, this typically only causes about a second of write unavailability.</p>

<p>Now you can <a href="http://vitess.io/user-guide/sharding-kubernetes.html#remove-the-original-shard">tear down the old shard</a>, and verify that only the new ones show up in the dashboard.</p>

<img src="/images/blog-2015-10-06-dashboard-3.png" alt="Screenshot of Vitess dashboard showing test keyspace with two shards at end of resharding process."/>

<p>Note that we never had to tell the app that we were changing from one shard to two. The resharding process was completely transparent to the app, since Vitess automatically reroutes queries on-the-fly as the migration progresses.</p>

<p>At YouTube, we've used Vitess to transparently reshard (both <a href="http://vitess.io/user-guide/sharding.html#supported-operations">horizontally and vertically</a>) nearly all of our MySQL databases within the last year alone, and we have still more on the horizon as we continue to grow. See the full <a href="http://vitess.io/user-guide/sharding-kubernetes.html">walkthrough instructions</a> if you want to try it out for yourself.</p>

<h2>Scaling Benchmarks</h2>

<p>The promise of sharding is that it allows you to scale write throughput linearly by adding more shards, since each shard is actually a separate database. The challenge in achieving that separation while still presenting a simple, unified view to the application is to avoid introducing bottlenecks. To demonstrate this scaling in the cloud, we've integrated the Vitess client with a driver for the <a href="https://github.com/youtube/YCSB">Yahoo! Cloud Serving Benchmark (YCSB)</a>.</p>

<p>Below you can see preliminary results for scaling write throughput by adding more shards in Vitess running on <a href="https://cloud.google.com/container-engine/">Google Container Engine</a>. For this benchmark, we pointed YCSB at the <a href="http://kubernetes.io/v1.0/docs/user-guide/services.html#type-loadbalancer">load balancer</a> for our Vitess cluster and told it to send a lot of INSERT statements. Vitess took care of routing statements to the various shards.</p>

<img src="/images/blog-2015-10-06-scaling-writes.png" alt="Scaling writes by adding shards - graph shows QPS latency threshold as number of shards increases"/>

<p>The max throughput (QPS) for a given number of shards is the point at which round-trip write latency became degraded, which we define as >15ms on average or >50ms for the worst 1% of queries (99th percentile).</p>

<p>We also ran YCSB's "read mostly" workload (95% reads, 5% writes) to show how Vitess can scale read traffic by adding replicas. The max throughput here is the point at which round-trip read latency became degraded, which we define as >5ms on average or >20ms for the worst 1% of queries.</p>

<img src="/images/blog-2015-10-06-scaling-reads.png" alt="Scaling reads by adding replicas - graph shows QPS latency threshold as number of replicas per shard changes"/>

<p>There's still a lot of room to improve the benchmarks (for example, by tuning the performance of MySQL itself). However, these preliminary results show that the returns don't diminish as you scale. And since you're scaling horizontally, you're not limited by the size of a single machine.</p>

<h2>Conclusion</h2>

<p>With the new cloud native version of Vitess moving towards a stable launch, we invite you to <a href="http://vitess.io/getting-started/">give it a try</a> and let us know what else you'd like to see in the final release. You can reach us either on our <a href="https://groups.google.com/forum/#!forum/vitess">discussion forum</a>, or by filing an issue on <a href="https://github.com/youtube/vitess">GitHub</a>. If you'd like to be notified of any updates on Vitess, you can subscribe to our low-frequency <a href="https://groups.google.com/forum/#!forum/vitess-announce">announcement list</a>.</p>
